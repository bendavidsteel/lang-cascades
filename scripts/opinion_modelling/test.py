import os

import torch

import pyro

import datasets
import discriminative
import generative

def test_choices_examples():
    this_dir_path = os.path.dirname(os.path.abspath(__file__))
    data_path = os.path.join(this_dir_path, '..', 'data', 'bertweet_base_5_100_100')

    batch_size = 1
    num_workers = 0
    pin_memory = False
    shuffle = True

    inter_dataset = discriminative.InteractionDataset(data_path)
    inter_dataloader = torch.utils.data.DataLoader(inter_dataset, batch_size=batch_size, shuffle=shuffle, num_workers=num_workers, pin_memory=pin_memory)

    pyro.enable_validation(True)
    pyro.set_rng_seed(1)

    trainer = discriminative.get_trainer(discriminative.choose_reply_comment)#, guide=choose_reply_comment_guide)

    example_seqs = [[0, 1]]

    # 14103
    # 10244
    # 5245

    for example_seq in example_seqs:
        running_loss = 0.
        for example_idx in example_seq:
            example = inter_dataset[example_idx]
            batch = inter_dataloader.collate_fn([example])

            user_state = batch['user_state']
            padded_comments_opinions = batch['padded_comments_opinions']
            mask_comments_opinions = batch['mask_comments_opinions']
            reply_comment = batch['reply_comment']

            loss = trainer.step(user_state, padded_comments_opinions, mask_comments_opinions, actual_reply_comment=reply_comment)
            running_loss += loss / batch_size

def test_dataset_collater():
    model_creator = generative.SocialGenerativeModel
    num_people = 10
    dataset = datasets.GenerativeDataset(model_creator, num_people=num_people, max_time_step=10)

    # ensure that data generated by the generative model corresponds to the data in the dataset
    for idx in range(num_people):
        batch = dataset[idx]
        user = dataset.user_df.iloc[idx]

        user_comments = dataset.comments_df[dataset.comments_df['author_id'] == user['user_id']]
        user_comments = user_comments.sort_values(by='time_step')

        num_comments = len(user_comments)

        # check that the user comments are in the right order
        user_comments_opinions = batch['user_comments_opinions']
        for i in range(num_comments):
            comment = user_comments.iloc[i]
            assert user_comments_opinions[i] == comment['pos']

            post = dataset.posts_df[dataset.posts_df['post_id'] == comment['post_id']].iloc[0]
            post_comments = dataset.comments_df[dataset.comments_df['post_id'] == post['post_id']]

            # check that the available content to reply to is correct
            reply_content_opinions = batch['reply_content_opinions']

            assert reply_content_opinions[i, 0] == post['pos']

            for j in range(len(post_comments)):
                reply_comment = post_comments.iloc[j]
                assert reply_content_opinions[i, j+1] == reply_comment['pos']

            # check that the chosen reply is correct
            chosen_reply_idx = batch['chosen_reply_idx']
            chosen_reply_id = user_comments.iloc[i]['reply_comment_id']
            chosen_reply_pos = post_comments[post_comments['comment_id'] == chosen_reply_id].iloc[0]['pos']

            assert reply_content_opinions[i, chosen_reply_idx[i]] == chosen_reply_pos

if __name__ == "__main__":
    test_dataset_collater()